재귀적으로 생각하지 말자
하지만 포기하지는 말자. 왜냐, 재귀 문제를 쉽게 푸는 방법은 분명 있기 때문이다.

처음엔 나도 어려웠지만, 무식하게 재귀 문제를 풀다보니 재귀 문제를 푸는 노하우가 생겼다.
이미 훌륭한 개발자들이 자신들의 노하우를 여러가지 방식으로 정리해놓은 걸 보니, 거의 비슷한 접근법을 쓰고 있었다.

이 접근법이 익숙해지고 나니, 이제는 재귀가 하나도 무섭지 않아졌다.

그 비결이 무엇이냐고? 그건 바로...

재귀적으로 생각하지 말 것.

읭? 이게 무슨 소리인가. 재귀 문제를 푸는데 재귀적으로 생각하지 말라고?

정확히 말하면, 머릿속에 함수 실행 순서를 그리려고 하지 말라는 말이다.

재귀 문제가 익숙해지고 쉬워진다는 건, 갑자기 내 머릿속에 함수 콜 스택이 어떻게 쌓이는지 쫙 그려지는 게 아니다. (물론 그런 대단한 사람이 있을 거다..)

대부분의 사람은 아무리 재귀를 풀어도 재귀의 재귀의 재귀...를 머릿속에 떠올리기 어렵다.

내 경우에는 오히려 그렇게 생각하지 않는 게 도움이 됐다. 머릿속에서 재귀 함수의 실행 순서를 그려보려고 하면 거기서부터 압도당해버린다.

즉, 처음부터 큰 그림을 머릿속에 그리려고 하지 않는다. 재귀 함수의 중요한 부분들에만 초점을 좁혀서 문제를 풀어나간다.

이렇게 하면 정말 재귀적으로 생각하지 않고도 재귀 문제를 풀 수 있다!


야, 너두 재귀할 수 있어!

재귀가 풀리는 4단계 접근법
1단계. 재귀를 꼭 써야 하는가?
2단계. 베이스 조건: 답을 바로 알 수 있는 가장 간단한 상황을 생각한다.
3단계. 분해: 베이스 조건에 가까워지도록 인풋값을 조작한다.
4단계. 조합: 부분 답을 가지고 전체 답을 구하는 방법을 생각해본다.

무조건 베이스 조건부터
재귀 함수를 풀 때, 가장 먼저 '베이스 조건'을 떠올려야 한다.

'베이스 조건'이란 더 이상 자기 자신을 호출하지 않게 하는 조건이다.
다시 말해, 재귀가 끝나는 조건이다.

베이스 조건이 재귀를 멈추는 조건이라고 하니 이렇게 생각하기 쉽다. '음... 어디까지 호출이 되고, 값이 어떤 상태가 되었을 때 재귀를 멈춰야하지? 하지만 이렇게 시작하면 안 된다!

그렇게 생각하면 머릿속으로 함수 실행 순서를 그려야 한다. 하지만 우리의 목표는 '최대한 재귀적으로 생각하지 않는 것'이다.

대신 이렇게 생각해본다.
베이스 조건은 단순한 작업으로, 바로 답을 구할 수 있는, 가장 쉬운 상황이다.

바로 답을 구할 수 있는, 가장 단순한 인풋값은 무엇일까?

마치 거저먹는 것처럼 느껴지는 그런 인풋값을 떠올려보자.

0과 1을 활용한 인풋
이 때 가장 간단한 인풋값은 0 혹은 1인 경우가 많다.

만약 정수 타입이 들어온다면,
인풋이 0이나 1인 상황을 생각해보자.

만약 배열이 들어온다면?
그러면 배열의 길이가 0인 경우(빈 배열), 배열의 길이가 1인 경우를 생각해보자.

만약 트리가 들어온다면?
인풋값이 nil인 경우, 혹은 자식 노드가 nil(잎 노드)인 경우를 생각해보자.

만약 인풋값이 2차원이라면?
인풋값이 m x n 그리드 (이차원 배열)이라면,
둘 다 0이거나 (m = 0, n = 0),
둘 중 하나가 1이거나 (m = 0, n = 1) (m = 1, n = 0)
둘 다 1인 (m=1, n=1) 케이스를 생각해보자.

0과 1을 사용한 인풋값이 들어왔을 때 즉각 답을 구할 수 있는가?
만약 YES라면, 그게 베이스 조건과, 베이스 조건에서의 결과값이 된다.

물론 0과 1이 항상 적절한 베이스 조건인 건 아니다. 추가적인 베이스 조건이 필요할 때도 있고, 둘 중 하나만 필요할 수도 있다. 하지만 대개 0과 1을 떠올리면 쉽게 베이스 조건을 찾을 수 있다.

문제에서 요구한 답의 데이터 타입
베이스 조건에서 무엇을 return 해야할지 헷갈린다면 문제에서 요구한 답의 데이터 타입을 보자.

예를 들어, 트리가 주어지고, 트리 안 어떤 경로의 '노드값 총합(정수)'를 구하는 문제다. 그러면 베이스 조건의 결과값은 '정수 타입'이다.

비슷하지만 조금 다른 문제. 트리가 주어지고, 특정한 경로의 '트리 노드 자체'를 구하는 문제다. 그러면 베이스 조건의 결과값은 '트리 노드 타입'이다.

이런 식이다. 베이스 조건만 주어져도 재귀 함수는 답을 뱉어야 한다.

문제가 요구하는 데이터 타입과 베이스 조건 결과값의 데이터 타입은 같아야 한다. 너무도 당연한 말이지만, 헷갈릴 땐 은근히 좋은 힌트가 된다.

다시 한번 강조하지만, 무조건 '베이스 조건'부터 생각해야 한다. 재귀로 풀어야겠다고 마음을 먹은 순간, 자동적으로 머릿속에 '베이스'가 떠올라야 한다.

베이스 조건은 문제를 쉽게 풀도록 도와주는 출발점이다.

예시로 주어진 인풋값을 보고, 어떻게 이걸 답으로 만들지? 라고 생각하면 안 된다. 자꾸 함수 실행 순서를 생각하게 되기 때문이다.

최대한 재귀적으로 생각하지 않고, 마치 1차원 문제인 것처럼 푸는 게 우리 전략이다.

3단계. 분해
베이스 조건에 가까워지도록 인풋값을 조작한다.

재귀적 분해 = 문제를 더 작게 만드는 것
베이스 조건을 정했다. 하지만 끝이 아니다. 재귀 함수가 잘 작동하려면, 함수를 호출할 때마다 베이스 조건에 가까워져야 한다.

자기 자신을 호출할 때, 넣을 인자를 한 단계 더 간단해지도록 조작한다.

예를 들어 n이라는 정수를 인자로 받았다면, 자기 자신을 호출할 때 n-1을 넣는 식이다. 그래야 재귀를 반복하면서 인풋값이 조금씩 더 간단해진다.

그러다 어느 순간 인풋값이 베이스 조건에 턱! 하고 걸린다. 재귀 호출이 멈춘다. 이제 값을 반환한다. 이게 재귀 함수의 기본 원리다.

이걸 영어로는 재귀적 분해(Recursive Decomposition)이라고 한다.

어려운 말처럼 들리지만, 인풋값을 간단하게 만들어서 문제를 더 작게 만드는 것. 이라고 생각하면 쉽다. 이 글에서는 편의상 ‘분해'라고 부르도록 하겠다.

자, 우리가 보고 있는 문제의 인풋값은 무엇인가? 이 값에 어떤 조작을 가해줘야 베이스 조건으로 향하게 될까?

분해의 흔한 패턴
‘분해’도 재귀 문제를 많이 풀다보면 비슷한 패턴이 반복된다.

정수 타입이라면 대체로 n - 1 혹은 n - 2.
배열이라면 앞의 숫자 하나를 떼고 길이를 줄인다. [1,2,3,4] → [2,3,4] → [3,4] 이런 식으로. 문자열도 마찬가지.
링크드 리스트라면, 포인터가 가리키는 다음 노드, 혹은 다다음 노드를 넣는다.
트리라면, 자식 노드를 하나씩 넣는다. (이진 트리의 경우 재귀 호출을 2번 하는 경우가 많다.)
‘분해'라고 해서 꼭 값을 줄이는 건 아니다.

하지만 계속 분해하다보면 우리가 원하는 베이스 조건에 도달해야 한다. 그게 중요하다.

분해를 어떻게 해야할지 바로 떠오르지 않아도 괜찮다. 문제에 따라서 분해가 상당히 복잡할 수 있다.

일단은 단순하게 가정하고 넘어가자. 어떤 분해가 적절한지 다음 ‘조합' 단계에서 힌트를 얻는 경우가 많다.

4단계. 조합
부분 답을 가지고 전체 답을 구하는 방법을 생각해본다.

조합은 재귀 호출이 베이스 조건에 걸려 멈추고 나서, 그 다음에 일어나는 작업이다.

베이스 조건에 도달하고, 거기서부터 마치 감았던 실타래를 풀듯이 결과값들이 차례차례 반환된다.

마치 테트리스에서 한 줄이 터지면 다음 블록이 내려오면서 연속적으로 터지는 그런 느낌이다. 재귀의 꽃이랄까.

1) 베이스 조건 바로 위의 단계
베이스 조건에 도달하고 나서, 재귀 함수가 결과값을 반환한다.

그 바로 윗 단계의 함수를 생각해본다. 분해를 하기 직전 함수가 실행되었을 때를 말한다.

n == 1 이 베이스 조건이다.
분해는 func(n-1)이었다.

그러면 베이스 조건 바로 윗단계의 함수는?
n이 2일 때다.

array.length == 1이 베이스 조건이다.
분해는 func(array.remove(at: 1)) 이었다.

그러면 베이스 조건 바로 윗단계의 함수는?
array 길이가 2일 때다.

예를 들어, n부터 1까지의 합을 구하는 함수를 짠다고 해보자.

n이 2일 때 어떤 답이 나와야 할까 생각해본다.

그냥 손으로 풀어보자. 베이스 바로 위의 인자값도 단순하다. 손으로 풀어도 답을 알 수 있다. f(2)는 당연히 3이다.

그 다음 베이스 조건에서 반환되는 값을 가지고, 이 답을 어떻게 만들지 생각해본다.

f(1)은 1이었다. 이걸로 어떻게 3을 만들까? 2를 더해주면 되지 않을까? 그러면 될 거 같다.

2) 베이스 조건의 3단계 위
이번에는 베이스 조건에서 3단계 위를 생각해본다.

사실 꼭 3단계일 필요는 없다. 아무거나 가정해도 좋다. 보통 베이스에서 3단계 위 지점까지는 직접 풀어도 쉽게 답이 나오고, 3단계 위 지점에서 제대로 작동한다면 대부분 잘 작동할 것이다. 그래서 3단계 위를 많이 가정하는 편이다.

앞에서 했던 것처럼 분해를 3번 뒤로 돌리면 된다.
n == 1이 베이스 조건이었으니, n이 4일 때 3단계 위가 된다.

n이 4일 때 답을 생각해본다. 4+3+2+1 = 10이다.

그리고 n이 3일 때 답을 생각해본다. 3+2+1 = 6이다.

일단 믿어본다
여기서 중요한 개념이 나온다. 바로 아랫단계의 재귀 호출에서 정답을 반환해준다고 가정하는 것이다.

우리는 아직 재귀 함수가 잘 설계되었는지 모른다. 하지만 일단은 f(3)을 호출하면 그냥 정답인 ‘6’을 구해준다고 믿어본다. 일단 어떤 방식으로 구현했는지 몰라도 ‘맞다 치고’ 해보는 거다.

그러면 조합을 생각하기가 쉬워진다.

왜냐하면 밑으로 내려가는 재귀 함수의 실행을 머릿속에 그릴 필요가 없기 때문이다. 그냥 아랫단계의 답이 나왔고, 그걸 어떻게 지금 단계의 답으로 만들 수 있을지만 생각해본다.

이걸 ‘재귀적 믿음의 점프 (Recursive leap of faith)’라고 부른다. 영어식 표현이라 어색하다면 그냥 ‘일단 믿어본다’로 기억하자.

이 믿음은 조합을 생각할 때 큰 도움이 된다.

왜냐하면 비록 베이스 조건에서 3단계만 위라고 하더라도, 재귀 호출이 2번 등장하는 트리나, 4번 등장하는 그리드 탐색 같은 경우엔 아랫단계의 실행 순서가 복잡하고 골치 아프기 때문이다. 하지만 구현은 됐고 일단 아래 단계에서 답이 나왔다고 가정하면, 조합을 구현하는 게 훨씬 쉬워진다.

두 케이스의 공통점을 찾는다
‘베이스 바로 위’ ‘베이스 3단계 위' 이 두가지 조합을 똑같은 방식으로 일치하게 할 수 있을까? 둘 다 정확한 답이 나올 수 있는 방식을 찾았다면, 재귀 설계는 끝났다.

이 2단계에서 제대로 답이 나온다면, 거의 모든 경우에 재귀는 자연스럽게 답으로 가게 되어있다. 마치 점 2개를 찍고 그 사이를 이으면 직선이 나오는 것처럼 말이다.

자 여기까지 끝났다면, 이제 베이스 조건, 분해, 조합의 순으로 코드를 작성하면 된다.

이 4단계는 그야말로 ‘접근법'이다. 대입하면 바로 풀리는 공식은 아니다.

하지만 알고리즘 문제를 재귀로 풀 때 가장 중요한 점은, 코드를 치기 전에 이런 접근법을 가지고 문제를 어떻게 풀지 생각해보는 것이다.

코드를 치기 전에 먼저 문제를 풀어야 한다. 머릿속으로 그려보다가 조금 복잡하다 싶으면, ‘일단 코드부터 작성하다보면 어떻게 되겠지 라는 마음으로 시작하기 쉽다. 그러면 막혔을 때 오랫동안 헤멘다. 내가 손으로 풀 수 없는 문제를 컴퓨터에게 시킬 수는 없다.

4단계를 차례로 생각해보면 코드를 치기 전에, 먼저 알고리즘을 설계할 수 있다. 코드를 쓰는 일이 훨씬 쉬워진다.

그냥 아랫단계의 답이 나왔고, 그걸 어떻게 지금 단계의 답으로 만들 수 있을지만 생각해본다.

두 케이스의 공통점을 찾는다
‘베이스 바로 위’ ‘베이스 3단계 위' 이 두가지 조합을 똑같은 방식으로 일치하게 할 수 있을까? 둘 다 정확한 답이 나올 수 있는 방식을 찾았다면, 재귀 설계는 끝났다.

이 2단계에서 제대로 답이 나온다면, 거의 모든 경우에 재귀는 자연스럽게 답으로 가게 되어있다. 마치 점 2개를 찍고 그 사이를 이으면 직선이 나오는 것처럼 말이다.